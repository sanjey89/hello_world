/*3. Создать базовый не-шаблонный класс Container (контейнер/коллекция), который содержит поле count 
(количесто элементов в коллекции), а также методы: GetCount, Add, Remove, Print, Search, Replace и Sort.
Ваши уже готовые не-шаблонные классы Array, Vector, SLL, DLL и BinaryTree сделать наследниками класса Container.
Переопределить методы в каждом классе-контейнере. Протестировать написанные классы.*/
#include <iostream>
#include <string>
using namespace std;

class Container
{
protected:
	int count;
	struct Elem{
		int data;
		Elem* next;
		Elem* prev;
	};
public:
	int GetCount()
	{
		  return count;
	}
};
class List:public Container
{
private:
	Elem* head;
	Elem* tail;
public:
	List(){
		head = tail = nullptr;
		count = 0;
	}
	void AddElem(int data)
	{
		Elem* temp = new Elem;
		temp->data = data;
		if (head == nullptr)
		{
			head = tail = temp;
			head->next = nullptr;
			head->prev = nullptr;
		}
		else
		{
			temp->next = head;
			head->prev = temp;
			head = temp;
			temp->prev = nullptr;
		}
		count++;
	}
	void AddTail(int data)
	{
		Elem* temp = new Elem;
		if (head == nullptr)
		{
			head = temp;
			tail = temp;
			head->data = data;
			head->next = nullptr;
			head->prev = nullptr;
			return;
		}
		temp->data = data;
		temp->next = nullptr;
		temp->prev = tail;
		tail->next = temp;
		tail = temp;
		count++;
	}
	int GetCount() const
	{
		return count;
	}
	int GetHead() const
	{
		return head->data;
	}

	int GetTail() const
	{
		return tail->data;
	}

	bool RemoveHead()
	{
		if (head != nullptr && count > 1)
		{
			Elem* temp = head;
			head = head->next;
			head->prev = nullptr;
			delete temp;
			count--;
		}
		else if (count == 1)
		{
			delete head;
			head = nullptr;
			tail = nullptr;
			count--;
		}
		else return false;
		return true;
	}

	bool RemoveTail()
	{
		if (head != nullptr && count > 1)
		{
			Elem* temp = tail;
			tail = tail->prev;
			tail->next = nullptr;
			delete temp;
			count--;
		}
		else if (count == 1)
		{
			delete tail;
			head = nullptr;
			tail = nullptr;
			count--;
		}
		else return false;
		return true;
	}
	Elem* GetElemAtIndex(unsigned index)
	{
		if (head == nullptr) return nullptr;
		else
		{
			Elem* current = head;
			for (int i = 0; i < index; i++)
			{
				current = current->next;
			}
			return current;
		}
	}
	bool RemoveAtIndex(int index)
	{
		Elem* current = head;
		if (index == 0)
			return RemoveHead();
		else if (index == count)
			return RemoveTail();
		else if (index > count) return false;
		else
		{
			Elem* temp = GetElemAtIndex(index);
			(temp->next)->prev = temp->prev;
			(temp->prev)->next = temp->next;
			delete temp;
		}
	}
	void Clear()
	{

		while (RemoveHead()){};
	}
	bool IsEmpty()
	{
		if (head == nullptr)
			return true;
		return false;
	}
	int SearchAsIndex(int index)
	{
		Elem* current = head;
		for (int i = 0;; i++)
		{
			if (i == index)
				return current->data;
			current = current->next;
		}
	}
	void Print()
	{
		Elem* current = head;
		while (current != nullptr)
		{
			cout << current->data << " ";
			current = current->next;
		}
	}
	void PrintRevers()
	{
		Elem* current = tail;
		while (current != nullptr)
		{
			cout << current->data << " ";
			current = current->prev;
		}
	}
};
